六大原则
程序架构设计、设计模式选择，应该遵循这六大原则。
1.单一职责原则
一个类只负责一个功能，这个功能的修改不影响其它类，这个类/功能可以被其它相似的类替换

2.开闭原则
对扩展开放，对修改关闭。
比如一个加载图片的工具类，原来是把图片缓存到内存，后来有个需求是缓存到硬盘/内存硬盘双缓存，这个时候，不是修改原来的“缓存到内存”方法，而是增加“缓存到硬盘”方法。
或者，“缓存”方法改为动态、可配置，通过注入“缓存工具实例”，调用该实例的缓存方法。注入不同的实例，最终缓存方法的实现就不一样

3.里氏替换原则
所有能够使用父类的地方，都应该能够使用子类替换
这个跟开闭原则、面向接口变成是紧密相连的，能够替换就说明传参是父类/接口，替换的目的一般是为了方便扩展、不需要修改具体实现就可以改变行为

4.依赖倒置原则
具体实现类依赖抽象接口，抽象接口不能依赖具体事先类
WindowManager需要管理View的显示，调用的也是View的各种方法，而不是具体的TextView、Button的方法，它只需要依赖View、引入View就行了，跟TextView等没有任何耦合关系

5.接口隔离原则
只暴露必须的方法，对其它方法不可见
比如AudioProxy有playMusic和playRadio方法，有的地方只用到playMusic方法，有的地方只用到playRadio方法。
那么比较好的做法就是让AudioProxy继承两个接口A、B，这两个接口分别有playMusic、playRadio方法。只需要playMusic方法的地方就用接口A，就不会暴露AudioProxy的其它方法

6.迪米特原则
只跟“直接朋友”发生联系
比如LeTingProxy只负责处理业务逻辑，只需要找LeTingPlayer，调用其pause、start等方法就行了，不关注pause是怎么实现的。LeTingPlayer只关注MediaPlayer的调用，而不关注编解码的具体实现。

设计模式
一、单例模式
不多说

二、Builder模式
解决问题：
1.当一个类有很多参数时，构造方法需要传很多参数，顺序还不能搞错，麻烦；
2.当一个类需要调多次setXXX才能完成初始化，而且调用顺序不能有误；
3.当一个类需要创建后就不可改变；

上面这3种情况就适合用Builder模式了。
类A的构造方法需要传入Builder实例，Builder实例中包含了所有A需要的字段。开发者通过创建Builder来存储参数，然后再通过Builder实例创建A的实例。

缺点是：
1.类A的实例一旦创建完成，就不可更改；
2.创建了多余的Builder对象，浪费内存；

三、工厂模式
解决问题：
1.创建过程很复杂、同类型具体类有多个，使用者只想知道怎么用，不关注创建。比如Bitmap - BitmapFactory；
2.隔离直接引用，业务修改或实体类修改都不会影响对方，只需要在Factoyr中做少量修改；
3.隐匿创建过程，常见于SDK开发；

抽象工厂模式：
如果实体类构成比较复杂、由多个因素共同决定，比如语音显示window，有带标题栏、带边框的全屏window，有不带标题栏、带边框的半屏window。。。。按照简单工厂模式的结构就是：createWindow1、createWindow2等等，每增加一个window子类时，增加一个createWindow方法，并且在这个新增方法里面把标题栏、边框等属性重新实现一遍，明显是代码冗余，所以出现了抽象工厂模式。

把每个因素的实现都抽象出来，然后需要什么类型的window，就创建一个该类型对应的factory（可以理解为新增了一个createXXX方法），这个factory里面直接调用因素的具体实现。

总结起来就是，简单工厂起到隔离的作用，抽象工厂是在简单工厂的基础上，解决了子类太多、太复杂时的代码重用、扩展。

四、策略模式
解决问题：
某个逻辑/业务处理，针对不同的情况，需要用不同的处理策略，需要加很多if-else判断，代码臃肿，扩展/修改时需要改整个代码。而且，如果确定只用case1，后面的case代码就全部是多余代码；

策略模式就是把这些if-else里面的不同之处抽象出来，每个策略生成一个子类。比如每个音乐app搜索音乐的方式都不一样，我们就可以把“搜索音乐”这个动作抽象出来，创建多个子类：QQ音乐搜索class、酷我音乐class。。。等等，初始化的时候，根据不同的app，注入不同的class（依赖注入原则）。符合开闭原则中的“对扩展开放，对修改关闭”。

android空间的setOnClickListener就是类似策略模式，由开发者注入具体实现，针对不同的情况，实现不同的策略。

五、状态模式
解决问题：
搜索音乐并播放，需要根据app决定具体实现，所以使用了策略模式。暂停音乐，又要根据app来决定，于是再次使用策略模式。关闭音乐又要根据app来决定。。。于是，你发现这样太繁琐了。

最终你决定把“QQ音乐搜索class”改名为“QQ音乐class”，这个新class里不仅有搜索音乐方法，还有暂停播放、关闭音乐等方法。这就是状态模式：根据不同状态（当前音频焦点app），决定当前动作的具体实现，这些状态在运行过程中是可变的。

应该说，状态模式就是特殊情况下的策略模式：多个有关联性的动作（搜索音乐、暂停播放、关闭音乐）的判断因素都是同一个（当前音频焦点app），并且判断因素是动态改变的。

如果判断的因素不是同一个，就不能使用状态模式。比如，搜索音乐需要判断当前音频焦点app；弹出悬浮窗需要判断当前栈顶应用；连接蓝牙需要判断车厂sdk；

如果多个动作业务关联性不大，也只能使用多个策略模式。比如，打开蓝牙，打开车上空调，设置tts欢迎语。这三个动作的判断因素虽然都是车厂，但是蓝牙、空调、tts这三个动作明显没有业务关联性，不能放在同一个类中，违反了单一原则。

判断因素不会动态改变，也不能完全算状态模式。比如，获取车身信息、设置车身音量、设置tts播报语，这些动作肯定会抽象成“威仕特设置class”，但是这个class是运行后就不会改变的、静态存在的，虽然代码结构有点类似状态模式，但本质不属于状态模式。

六、责任链模式
解决问题：
QQ音乐正在播放中，语音发出一条指令：播放电台节目逻辑思维，客户端接收到指令后需要做如下事情：解析指令意图，停止音乐播放，打开喜马拉雅，搜索逻辑思维，播放搜索出来的节目。一条指令就要做这么多逻辑处理，耦合非常严重，代码会非常臃肿、扩展/维护困难

通过责任链模式，把上面4个步骤分成：负责指令解析的类，负责音频焦点处理的类，负责操作sdk的类。指令解析类只负责解析指令，其他操作不处理，交给下一个类；音频焦点处理类只负责处理当前的音频焦点（谁播谁不播），其他操作交给下一个类；操作sdk类只负责调用sdk，具体的搜索执行交给具体的音频app。

这样，看似很复杂的一个动作，通过分解/解耦，维护/扩展起来相对比较轻松。

Android中View的绘制典型的责任链模式，父控件能处理的就是绘制自己、测量子控件，然后通知子控件自己绘制自己

七、解释器模式
json解析就是一个典型的解释器模式：按照固定的“语法”书写内容，开发者通过对应的解释器类，解析json文本中的信息，生成不同的对象。

Android中的manifest也是，加载apk时，就会有专门的解释器对manifest进行解析，生成对应的Activity对象、Service对象等等。

主要用于配置文件、动态装配。

八、命令模式
把一个命令封装成一个类，这样，调某个指令的时候，是传入这个类的实例。方便解耦。。。。。这个模式很懵逼

九、迭代器模式
解决问题：
业务场景下需要遍历某个List/Array/Link，就需要自己写for循环、外加各种判断逻辑，很麻烦。如果让这些List/Array/Link实现这些遍历算法，又违背了单一职责原则。

所以需要一个专门负责迭代（或其它算法）的类，俗称迭代器。现在的高级语言一把都自带迭代器了，不需要自己实现，包括Android的数据库操作类Cusor，就是针对sqlite的迭代器。

延伸一下，使用场景具有如下特点：
1.有一个容器存储数据；
2.业务需要对这个容器、容器里的数据进行一些公用的逻辑操作，比如返回当前、返回下一个、重置游标、遍历等等；
歌曲的播放列表就可以考虑使用这种模式，PlayList类中使用List<T>存储歌曲文件，建一个内部类PlayListIterator类专门实现上一曲、下一曲、获取当前歌曲等等逻辑操作，实际上这种思维就是迭代器模式。

十、模版方法模式
一个接口可能会有很多个子类，每个子类的主体流程是固定的，但流程中的每一步实现又不一样。。。。好吧，直接说吧，具是View和Activity这种，要按固定顺序要调那几个方法，但是每个方法的实现要放在子类实现

十一、代理模式
代理模式主要解决以下问题：
1.实际执行处不想暴露过多代码，可以使用代理封装。比如各音乐APP厂商提供的SDK；
2.业务代码处只处理业务逻辑，不关注实际执行。比如ActivityHelper就是专门做执行层的；
3.实际执行处是多变的，需要根据情况而定，这部分判断加在业务代码上不合适。比如AiMedia；

其实说白了，就是遵循单一原则、以及解耦原则。

十二、中介模式
解决问题：
某个事件的结果，由多个因素共同决定，每个因素的行为受其它几个因素的影响，这样就会产生多对多的引用关系、逻辑处理关系

中介模式，每个因素都只和一个中介者产生引用/被引用关系，把自己的诉求告诉中介者、接收中介者的通知

比如，播放列表、播放器、本地音乐列表、收藏列表等是相互作用、相互影响的，创建一个中介类，持有这4个类的实例，同时，这4个实例也向中介类注册自己需要的回调。所有改变都通知中介，同时也接收中介的通知，类似事件总线。

十三、装饰者模式
一个类有多个可选属性，比如一个View，是否有title、是否有head、是否有侧边栏等等可选属性，这些可选属性都是可以任意组合的，如果每种情况都用一个子类来表示，那类的数量就太多了。

解决方案就是，View类只负责必须的功能、属性，比如show()、getWidth()等等。每一个可选功能封装成一个单独的类，继承View，比如“带title的View、带head的View”。这样，需要某个特性时，使用这个特性对应的类封装一次就OK了。

注意和Builder模式的异同：
相同点：
1.都是一个类有多个属性，根据各个属性的值决定最终对象的不同；

不同点：
1.Builder模式中，这些属性是必选项，装饰者模式是可选项；
2.Builder模式中，始化完成后就不可变，装饰者模式的对象是可变的；
3.Builder模式中的主要目的是隐藏类的创建过程，提供统一、简单的初始化方法，装饰者模式的主要目的是动态生成不同的对象，并且可能一直随业务的执行不停变化。
